"""
{app_name} Main Launcher
Upgrades library and runs the application using the virtual environment
"""
import subprocess
import sys
from pathlib import Path
import configparser
import os

def main():
    # Get paths
    app_dir = Path(__file__).parent
    venv_python = app_dir / "{venv_dir_name}" / "Scripts" / "python.exe"
    
    if not venv_python.exists():
        import tkinter as tk
        from tkinter import messagebox
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Error", f"Python not found at {venv_python}")
        return
    
    # Load debug setting from launch config
    launch_config_parser = configparser.ConfigParser()
    launch_config_file = app_dir / "launch_config.ini"
    debug_mode = False
    if launch_config_file.exists():
        launch_config_parser.read(launch_config_file)
        debug_str = launch_config_parser.get('Settings', 'debug', fallback='false')
        debug_mode = debug_str.lower() in ('true', '1', 'yes', 'on')
    
    # Windows flag to hide console (only if not in debug mode)
    CREATE_NO_WINDOW = 0x08000000
    creation_flags = 0 if debug_mode else CREATE_NO_WINDOW
    capture_output = not debug_mode  # Don't capture output if in debug mode
    
    try:
        # Step 1: Upgrade the library
        upgrade_result = subprocess.run(
            [str(venv_python), "-m", "pip", "install", "--upgrade", "{library_name}"],
            capture_output=True,  # Always capture to check for errors
            creationflags=creation_flags
        )
        
        if upgrade_result.returncode != 0:
            if debug_mode:
                print(f"Upgrade warning: {upgrade_result.stderr}")
            # Continue anyway - library might already be up to date
        
        # Step 2: Create a runner script that handles launch config
        runner_script = f'''
import sys
import configparser
from pathlib import Path

# Load launch config
app_dir = Path(__file__).parent
config = configparser.ConfigParser()
config_file = app_dir / "launch_config.ini"
launch_config = {{}}
if config_file.exists():
    config.read(config_file)
    if config.has_section('DEFAULT'):
        launch_config = dict(config['DEFAULT'])

# Import and run the library
try:
    import {library_name}
    {library_name}.run(launch_config)
except ImportError as e:
    print(f"Import error: {{e}}")
    print(f"Python path: {{sys.path}}")
    print(f"Python executable: {{sys.executable}}")
    raise
except Exception as e:
    print(f"Runtime error: {{e}}")
    raise
'''
        
        # Step 3: Run the library using the venv Python with the runner script
        result = subprocess.run(
            [str(venv_python), "-c", runner_script],
            cwd=str(app_dir),  # Set working directory
            capture_output=capture_output,
            creationflags=creation_flags
        )
        
        # If there was an error, show details
        if result.returncode != 0:
            error_msg = "Application failed"
            if capture_output and result.stderr:
                error_msg += f": {result.stderr}"
            elif capture_output and result.stdout:
                error_msg += f": {result.stdout}"
            else:
                error_msg += f" with exit code: {result.returncode}"
            raise Exception(error_msg)
        
    except Exception as e:
        import tkinter as tk
        from tkinter import messagebox
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Error", f"Failed to start application: {e}")

if __name__ == "__main__":
    main()