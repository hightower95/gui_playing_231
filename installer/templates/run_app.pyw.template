"""
{app_name} Main Launcher
Intelligent version management and application runner
"""
import subprocess
import sys
from pathlib import Path
import configparser
import os
import json
import re
from datetime import datetime
from typing import Optional, List, Dict, Tuple

from typing import Optional, List, Dict, Tuple


def log_upgrade_event(app_dir: Path, event_type: str, **kwargs):
    """Log upgrade events to upgrade_history.log"""
    try:
        log_file = app_dir / "upgrade_history.log"
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Format event data
        event_data = " | ".join([str(k) + "=" + str(v) for k, v in kwargs.items()])
        log_entry = timestamp + " | " + event_type + " | " + event_data + "\n"
        
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    except Exception:
        pass  # Silent fail for logging


def parse_version(version_str: str) -> Tuple[int, int, int]:
    """Parse semantic version string into (major, minor, patch)"""
    try:
        match = re.match(r'^(\d+)\.(\d+)\.(\d+)', version_str)
        if match:
            return (int(match.group(1)), int(match.group(2)), int(match.group(3)))
    except Exception:
        pass
    return (0, 0, 0)


def is_stable_version(version_str: str) -> bool:
    """Check if version is stable (even minor version)"""
    major, minor, patch = parse_version(version_str)
    return minor % 2 == 0


def get_installed_version(venv_python: Path, library_name: str) -> Optional[str]:
    """Get currently installed library version"""
    try:
        result = subprocess.run(
            [str(venv_python), "-m", "pip", "show", library_name],
            capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if line.startswith('Version:'):
                    return line.split(':', 1)[1].strip()
    except Exception:
        pass
    return None


def get_all_versions(venv_python: Path, library_name: str) -> List[str]:
    """Get all available versions from PyPI"""
    try:
        result = subprocess.run(
            [str(venv_python), "-m", "pip", "index", "versions", library_name],
            capture_output=True, text=True, timeout=60
        )
        if result.returncode == 0:
            versions = []
            for line in result.stdout.split('\n'):
                # Parse pip index output format
                if 'Available versions:' in line:
                    version_part = line.split('Available versions:', 1)[1]
                    versions = [v.strip() for v in version_part.split(',') if v.strip()]
                    break
            return versions
    except Exception:
        pass
    return []


def get_latest_stable_version(venv_python: Path, library_name: str, current_major: int) -> Optional[str]:
    """Get latest stable version within the same major version"""
    try:
        all_versions = get_all_versions(venv_python, library_name)
        stable_versions = []
        
        for version in all_versions:
            major, minor, patch = parse_version(version)
            if major == current_major and is_stable_version(version):
                stable_versions.append((version, major, minor, patch))
        
        # Sort by version tuple and return latest
        if stable_versions:
            stable_versions.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True)
            return stable_versions[0][0]
    except Exception:
        pass
    return None


def should_upgrade(current_version: str, config: Dict[str, bool], venv_python: Path, library_name: str) -> Optional[str]:
    """Determine if and to which version we should upgrade"""
    current_major, current_minor, current_patch = parse_version(current_version)
    allow_test_releases = config.get('allow_upgrade_to_test_releases', False)
    
    # Get upgrade permissions
    auto_upgrade_major = config.get('auto_upgrade_major_version', False)
    auto_upgrade_minor = config.get('auto_upgrade_minor_version', False)  # Default false for safety
    auto_upgrade_patches = config.get('auto_upgrade_patches', False)  # Default false for safety
    
    # If no upgrades are enabled, skip
    if not (auto_upgrade_major or auto_upgrade_minor or auto_upgrade_patches):
        return None
    
    # Get all available versions
    all_versions = get_all_versions(venv_python, library_name)
    candidate_versions = []
    
    for version in all_versions:
        major, minor, patch = parse_version(version)
        
        # Skip if it's a test release and not allowed
        if not allow_test_releases and not is_stable_version(version):
            continue
        
        # Determine upgrade type needed
        if major > current_major:
            # Major version upgrade
            if auto_upgrade_major:
                candidate_versions.append((version, major, minor, patch, 'major'))
        elif major == current_major and minor > current_minor:
            # Minor version upgrade within same major
            if auto_upgrade_minor:
                candidate_versions.append((version, major, minor, patch, 'minor'))
        elif major == current_major and minor == current_minor and patch > current_patch:
            # Patch version upgrade within same minor
            if auto_upgrade_patches:
                candidate_versions.append((version, major, minor, patch, 'patch'))
    
    # If we have candidates, return the latest one
    if candidate_versions:
        # Sort by version tuple and return latest
        candidate_versions.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True)
        return candidate_versions[0][0]
    
    return None


def upgrade_to_version(venv_python: Path, library_name: str, target_version: str) -> bool:
    """Upgrade to specific version"""
    try:
        result = subprocess.run(
            [str(venv_python), "-m", "pip", "install", library_name + "==" + target_version],
            capture_output=True, text=True, timeout=300
        )
        return result.returncode == 0
    except Exception:
        return False


def main():
    # Get paths
    app_dir = Path(__name__).parent
    venv_python = app_dir / "{venv_dir_name}" / "Scripts" / "python.exe"
    
    if not venv_python.exists():
        import tkinter as tk
        from tkinter import messagebox
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Error", "Python not found at " + str(venv_python))
        return
    
    # Load launch configuration
    launch_config_parser = configparser.ConfigParser()
    launch_config_file = app_dir / "launch_config.ini"
    
    # Parse config with safe defaults (false if missing/malformed)
    enable_log = False
    auto_upgrade_major = False  # Safe default
    auto_upgrade_minor = False  # Safe default
    auto_upgrade_patches = False  # Safe default
    allow_test_releases = False
    
    if launch_config_file.exists():
        try:
            launch_config_parser.read(launch_config_file)
            enable_log_str = launch_config_parser.get('Settings', 'enable_log', fallback='false')
            enable_log = enable_log_str.lower() in ('true', '1', 'yes', 'on')
            
            auto_upgrade_major_str = launch_config_parser.get('Settings', 'auto_upgrade_major_version', fallback='false')
            auto_upgrade_major = auto_upgrade_major_str.lower() in ('true', '1', 'yes', 'on')
            
            auto_upgrade_minor_str = launch_config_parser.get('Settings', 'auto_upgrade_minor_version', fallback='false')
            auto_upgrade_minor = auto_upgrade_minor_str.lower() in ('true', '1', 'yes', 'on')
            
            auto_upgrade_patches_str = launch_config_parser.get('Settings', 'auto_upgrade_patches', fallback='false')
            auto_upgrade_patches = auto_upgrade_patches_str.lower() in ('true', '1', 'yes', 'on')
            
            allow_test_str = launch_config_parser.get('Settings', 'allow_upgrade_to_test_releases', fallback='false')
            allow_test_releases = allow_test_str.lower() in ('true', '1', 'yes', 'on')
        except Exception:
            # Config parsing failed, use safe defaults
            pass
    
    config = {{
        "auto_upgrade_major_version": auto_upgrade_major,
        "auto_upgrade_minor_version": auto_upgrade_minor,
        "auto_upgrade_patches": auto_upgrade_patches,
        "allow_upgrade_to_test_releases": allow_test_releases,
        "enable_log": enable_log
    }}
    
    # Windows flag to hide console
    CREATE_NO_WINDOW = 0x08000000
    creation_flags = CREATE_NO_WINDOW
    
    try:
        # Step 1: Intelligent version management
        current_version = get_installed_version(venv_python, "{library_name}")
        
        if current_version:
            log_upgrade_event(app_dir, "VERSION_CHECK", 
                            current=current_version,
                            config=str(config))
            
            target_version = should_upgrade(current_version, config, venv_python, "{library_name}")
            
            if target_version:
                log_upgrade_event(app_dir, "UPGRADE_START",
                                current=current_version,
                                target=target_version,
                                reason="intelligent_upgrade")
                
                upgrade_success = upgrade_to_version(venv_python, "{library_name}", target_version)
                
                if upgrade_success:
                    log_upgrade_event(app_dir, "UPGRADE_COMPLETE",
                                    result="success",
                                    new_version=target_version)
                else:
                    log_upgrade_event(app_dir, "UPGRADE_COMPLETE",
                                    result="failed",
                                    target=target_version)
                    # Continue with current version on upgrade failure
            else:
                log_upgrade_event(app_dir, "UPGRADE_SKIP",
                                current=current_version,
                                reason="no_upgrade_needed")
        else:
            # Library not installed, this shouldn't happen but handle gracefully
            log_upgrade_event(app_dir, "VERSION_CHECK",
                            current="not_found",
                            config=str(config))
            
            # Try a simple install as fallback
            subprocess.run(
                [str(venv_python), "-m", "pip", "install", "{library_name}"],
                capture_output=True, text=True, timeout=300
            )
        
        # Step 2: Create a runner script that handles launch config  
        runner_script = '''
import sys
import configparser
from pathlib import Path

# Load launch config
app_dir = Path(__name__).parent
config = configparser.ConfigParser()
config_file = app_dir / "launch_config.ini"
launch_config = dict()
if config_file.exists():
    config.read(config_file)
    # Read from Settings section (preferred) or fall back to DEFAULT
    if config.has_section('DEFAULT'):
        launch_config = dict(config['DEFAULT'])

# Import and run the library
try:
    import {library_name}
    {library_name}.run(launch_config)

    print("Python executable: " + str(sys.executable))
    raise
except Exception as e:
    print("Runtime error: " + str(e))
    raise
'''
        
        # Step 3: Run the library using the venv Python with the runner script
        # Always capture output for logging purposes
        result = subprocess.run(
            [str(venv_python), "-c", runner_script],
            cwd=str(app_dir),  # Set working directory
            capture_output=True,  # Always capture for logging
            text=True,  # Decode output as text
            creationflags=creation_flags
        )
        
        # Comprehensive logging to file (only if enabled)
        if config.get('enable_log', False):
            log_file = app_dir / "last_run_log.txt"
            try:
                import datetime
                import platform
                with open(log_file, 'w', encoding='utf-8') as f:
                    # Header with timestamp
                    f.write("=" * 80 + "\\n")
                    f.write("=== {app_name} - COMPREHENSIVE RUN LOG ===\\n")
                    f.write("=== " + str(datetime.datetime.now()) + " ===\\n")
                    f.write("=" * 80 + "\\n\\n")
                    
                    # System Information
                    f.write("=== SYSTEM INFORMATION ===\\n")
                    f.write("Platform: " + platform.platform() + "\\n")
                    f.write("Python Version: " + platform.python_version() + "\\n")
                    f.write("Architecture: " + platform.machine() + "\\n")
                    f.write("Processor: " + platform.processor() + "\\n")
                    f.write("Working Directory: " + str(app_dir) + "\\n")
                    f.write("\\n")
                    
                    # Virtual Environment Information  
                    f.write("=== VIRTUAL ENVIRONMENT ===\\n")
                    f.write("Virtual Environment Path: " + str(venv_python) + "\\n")
                    f.write("Venv Exists: " + str(venv_python.exists()) + "\\n")
                    if venv_python.exists():
                        f.write("Venv Directory: " + str(venv_python.parent.parent) + "\\n")
                    else:
                        f.write("ERROR: Virtual environment not found!\\n")
                    f.write("\\n")
                    
                    # Configuration Information
                    f.write("=== CONFIGURATION ===\\n")
                    f.write("App Name: {app_name}\\n")
                    f.write("Library Name: {library_name}\\n") 
                    f.write("Venv Directory Name: {venv_dir_name}\\n")
                    f.write("Auto Upgrade Major: " + str(config.get("auto_upgrade_major_version", False)) + "\\n")
                    f.write("Auto Upgrade Minor: " + str(config.get("auto_upgrade_minor_version", False)) + "\\n")
                    f.write("Auto Upgrade Patches: " + str(config.get("auto_upgrade_patches", False)) + "\\n")
                    f.write("Allow Test Releases: " + str(config.get("allow_upgrade_to_test_releases", False)) + "\\n")
                    f.write("Enable Log: " + str(config.get("enable_log", False)) + "\\n")

                    f.write("Launch Config File: " + str(launch_config_file) + "\\n")
                    f.write("Launch Config Exists: " + str(launch_config_file.exists()) + "\\n")
                    
                    # Read and log the actual launch config content
                    if launch_config_file.exists():
                        f.write("\\n--- Launch Config Content ---\\n")
                        try:
                            with open(launch_config_file, 'r', encoding='utf-8') as config_file:
                                f.write(config_file.read())
                        except Exception as e:
                            f.write("Error reading config file: " + str(e) + "\\n")
                        f.write("--- End Launch Config ---\\n")
                    f.write("\\n")
                    
                    # Upgrade History
                    f.write("=== UPGRADE HISTORY ===\\n")
                    upgrade_history_file = app_dir / "upgrade_history.log"
                    if upgrade_history_file.exists():
                        try:
                            with open(upgrade_history_file, 'r', encoding='utf-8') as history_file:
                                recent_lines = history_file.readlines()[-10:]  # Last 10 events
                                f.write("--- Recent Upgrade Events ---\\n")
                                for line in recent_lines:
                                    f.write(line)
                                f.write("--- End Upgrade History ---\\n")
                        except Exception as e:
                            f.write("Error reading upgrade history: " + str(e) + "\\n")
                    else:
                        f.write("No upgrade history file found\\n")
                    f.write("\\n")
                    
                    # Execution Information
                    f.write("=== EXECUTION DETAILS ===\\n")
                    f.write("Exit Code: " + str(result.returncode) + "\\n")
                    f.write("Command: " + str(venv_python) + " -c <runner_script>\\n")
                    f.write("Working Directory: " + str(app_dir) + "\\n")
                    f.write("Creation Flags: " + str(creation_flags) + "\\n")
                    f.write("\\n")
                
                    # Runner Script Content
                    f.write("=== RUNNER SCRIPT ===\\n")
                    f.write(runner_script)
                    f.write("\\n=== END RUNNER SCRIPT ===\\n\\n")
                    
                    # Application Output - Always log captured output
                    f.write("=== APPLICATION OUTPUT ===\\n")
                    
                    # Always log stdout (captured in both debug and normal mode)
                    if hasattr(result, 'stdout') and result.stdout:
                        f.write("--- STDOUT ---\\n")
                        f.write(result.stdout)
                        f.write("\\n--- END STDOUT ---\\n\\n")
                    else:
                        f.write("--- STDOUT ---\\n")
                        f.write("(No stdout output)\\n\\n")
                    
                    # Always log stderr (captured in both debug and normal mode)  
                    if hasattr(result, 'stderr') and result.stderr:
                        f.write("--- STDERR ---\\n")
                        f.write(result.stderr)
                        f.write("\\n--- END STDERR ---\\n\\n")
                    else:
                        f.write("--- STDERR ---\\n")
                        f.write("(No stderr output)\\n\\n")
                    

                    
                    # Footer
                    f.write("=" * 80 + "\\n")
                    f.write("=== END OF LOG ===\\n")
                    f.write("=" * 80 + "\\n")
                    
            except Exception as log_error:
                print("Warning: Could not write comprehensive log file: " + str(log_error))

        
        # If there was an error, show details to user
        if result.returncode != 0:
            error_msg = "Application failed"
            error_details = ""
            
            # Collect error details
            if result.stderr:
                error_details = result.stderr.strip()
            elif result.stdout:
                error_details = result.stdout.strip()
            
            if error_details:
                error_msg += ":\n\n" + error_details
            else:
                error_msg += " with exit code: " + str(result.returncode)
            
            # Always show error to user via message box
            import tkinter as tk
            from tkinter import messagebox
            root = tk.Tk()
            root.withdraw()
            messagebox.showerror("Application Error", error_msg)
            return
        
    except Exception as e:
        import tkinter as tk
        from tkinter import messagebox
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Startup Error", "Failed to start application: " + str(e))

if __name__ == "__main__":
    main()